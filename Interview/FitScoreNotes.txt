===================================================================================
                    ðŸ“Š FIT SCORE CALCULATION IMPLEMENTATION
===================================================================================

ðŸ“– WHAT IS THIS?
---------------
This document explains how AI-powered job-resume matching (fit score) works.

===================================================================================
                         SECTION 1: OVERVIEW
===================================================================================

Q: What is a fit score?
-----------------------
A: A percentage (0-100%) indicating how well a resume matches a job requirement.

   Components:
   - Skills Match (40%): How many required skills match resume
   - Experience Match (30%): Years of experience alignment
   - Education Match (20%): Degree/qualification alignment
   - Overall Alignment (10%): General fit assessment

Q: Why use AI for this?
----------------------
A: Manual matching is:
   - Time-consuming (92+ jobs to check)
   - Subjective (different interpretations)
   - Inconsistent (different criteria each time)
   
   AI provides:
   - Fast batch processing
   - Consistent criteria
   - Objective analysis

===================================================================================
                         SECTION 2: DATA EXTRACTION
===================================================================================

STEP 1: RESUME PROCESSING
--------------------------
ðŸ“ FILE: AI/rag_service.py

1. User uploads PDF resume
2. OCR extracts text (if scanned PDF)
3. Text is chunked into smaller pieces
4. Each chunk converted to embeddings
5. Stored in Qdrant vector database
6. GPT-4 extracts structured data:
   - Skills (array)
   - Experience (years, companies, roles)
   - Education (degree, university, year)
   - Projects (titles, descriptions)

CODE FLOW:
----------
def extract_resume_data(pdf_path: str) -> Dict:
    # 1. Extract text from PDF
    text = extract_text_from_pdf(pdf_path)  # Uses OCR if needed
    
    # 2. Chunk text
    chunks = chunk_text(text, chunk_size=1000)
    
    # 3. Create embeddings and store in Qdrant
    for chunk in chunks:
        embedding = create_embedding(chunk)
        qdrant_client.upsert(
            collection_name="resume_chunks",
            points=[PointStruct(id=chunk_id, vector=embedding, payload={"text": chunk})]
        )
    
    # 4. Use GPT-4 to extract structured data
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "Extract skills, experience, education from resume"},
            {"role": "user", "content": text}
        ]
    )
    
    # 5. Parse and return structured data
    return parse_resume_data(response.choices[0].message.content)

STEP 2: JOB DATA
----------------
ðŸ“ FILE: backend/models/Job.js

Jobs stored in MongoDB with:
- title: "Software Engineer"
- company: "Google"
- description: Full job description
- skills: ["Python", "JavaScript", "React"]
- experience: "2-4 years"
- education: "Bachelor's in CS"
- location, salary, etc.

===================================================================================
                         SECTION 3: FIT SCORE CALCULATION
===================================================================================

METHOD 1: INDIVIDUAL SCORE (ON-DEMAND)
--------------------------------------
ðŸ“ FILE: backend/services/aiService.js

Called when:
- User views a specific job
- Fit score not cached
- Need quick calculation

CODE FLOW:
----------
async function calculateFitScore(resumeData, jobData) {
    // 1. Prepare prompt with resume and job data
    const prompt = `
        Resume Skills: ${resumeData.skills.join(", ")}
        Resume Experience: ${resumeData.experience} years
        Resume Education: ${resumeData.education}
        
        Job Required Skills: ${jobData.skills.join(", ")}
        Job Experience Required: ${jobData.experience}
        Job Education Required: ${jobData.education}
        
        Calculate fit score (0-100%) with:
        - Skills Match: 40%
        - Experience Match: 30%
        - Education Match: 20%
        - Overall Alignment: 10%
        
        IMPORTANT: If resume has NO formal work experience, penalize heavily.
        Projects can give partial credit but not full experience points.
    `;
    
    // 2. Call AI service
    const response = await axios.post("http://localhost:8000/rag/fit-score", {
        resume_data: resumeData,
        job_data: jobData
    });
    
    // 3. Extract score from response
    const score = response.data.score;
    
    // 4. Cache in MongoDB
    await FitScore.findOneAndUpdate(
        { userId: userId, jobId: jobId },
        { score, calculatedAt: new Date() },
        { upsert: true }
    );
    
    return score;
}

METHOD 2: BATCH SCORE (BACKGROUND JOB)
---------------------------------------
ðŸ“ FILE: AI/fast_fit_score.py

Called when:
- User uploads new resume
- Need to calculate scores for all jobs
- Background processing (doesn't block user)

CODE FLOW:
----------
@app.post("/fast/batch-fit-scores")
async def batch_fit_scores(request: BatchFitScoreRequest):
    resume_data = request.resume_data
    jobs = request.jobs  # Array of all jobs
    
    results = []
    
    # Process all jobs
    for job in jobs:
        # 1. Prepare batch prompt
        prompt = create_batch_prompt(resume_data, job)
        
        # 2. Call GPT-4
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[
                {"role": "system", "content": "You are a job matching expert..."},
                {"role": "user", "content": prompt}
            ]
        )
        
        # 3. Parse score
        score = parse_score_from_response(response)
        
        results.append({
            "job_id": job["_id"],
            "score": score
        })
    
    return {"scores": results}

ðŸ“ FILE: backend/services/backgroundJobs.js

TRIGGERS BATCH CALCULATION:
---------------------------
async function calculateAllJobMatches(userId) {
    // 1. Get user's resume data
    const resume = await Resume.findOne({ userId });
    const resumeData = await extractResumeData(resume.filename);
    
    // 2. Get all jobs
    const jobs = await Job.find({});
    
    // 3. Call AI service batch endpoint
    const response = await axios.post("http://localhost:8000/fast/batch-fit-scores", {
        resume_data: resumeData,
        jobs: jobs.map(job => ({
            _id: job._id.toString(),
            title: job.title,
            company: job.company,
            skills: job.skills,
            experience: job.experience,
            education: job.education,
            description: job.description
        }))
    });
    
    // 4. Save all scores to MongoDB
    for (const result of response.data.scores) {
        await FitScore.findOneAndUpdate(
            { userId, jobId: result.job_id },
            { score: result.score, calculatedAt: new Date() },
            { upsert: true }
        );
    }
}

===================================================================================
                         SECTION 4: SCORING LOGIC
===================================================================================

SKILLS MATCH (40%):
-------------------
Algorithm:
1. Count matching skills between resume and job
2. Calculate: (matching_skills / total_required_skills) * 40

Example:
- Job requires: ["Python", "JavaScript", "React", "Node.js"]
- Resume has: ["Python", "JavaScript", "Java"]
- Matching: 2 out of 4
- Score: (2/4) * 40 = 20 points

EXPERIENCE MATCH (30%):
-----------------------
Algorithm:
1. Extract years from resume and job
2. If exact match: 30 points
3. If within range: 25-28 points
4. If close (within 1 year): 20 points
5. If no experience but job requires: 0-5 points (heavily penalized)

Example:
- Job requires: "2-4 years"
- Resume has: "3 years"
- Score: 28 points (within range)

IMPORTANT: Freshers (0 years) get penalized for senior roles.

EDUCATION MATCH (20%):
----------------------
Algorithm:
1. Compare degree levels (Bachelor's, Master's, PhD)
2. Compare fields (CS, Engineering, etc.)
3. Calculate match percentage

Example:
- Job requires: "Bachelor's in Computer Science"
- Resume has: "Bachelor's in Computer Science"
- Score: 20 points (perfect match)

OVERALL ALIGNMENT (10%):
-----------------------
GPT-4 analyzes:
- Resume projects relevance to job
- Career trajectory alignment
- Cultural fit indicators
- Soft skills mentioned

===================================================================================
                         SECTION 5: CACHING STRATEGY
===================================================================================

WHY CACHE?
----------
- Fit scores don't change unless resume or job changes
- Recalculating 92 jobs takes 2-3 minutes
- Caching provides instant results

CACHE STRUCTURE:
----------------
ðŸ“ FILE: backend/models/FitScore.js

Schema:
{
    _id: ObjectId,
    userId: ObjectId (ref: User),
    jobId: ObjectId (ref: Job),
    score: Number (0-100),
    calculatedAt: Date
}

Indexes:
- { userId: 1, jobId: 1 }: Unique compound index for fast lookups

CACHE LOOKUP:
-------------
ðŸ“ FILE: backend/routes/recommendations.js

async function getRecommendations(userId) {
    // 1. Get cached scores
    const fitScores = await FitScore.find({ userId });
    const scoreMap = {};
    fitScores.forEach(fs => {
        scoreMap[fs.jobId.toString()] = fs.score;
    });
    
    // 2. Get all jobs
    const jobs = await Job.find({});
    
    // 3. Attach scores
    const jobsWithScores = jobs.map(job => ({
        ...job.toObject(),
        fitScore: scoreMap[job._id.toString()] || null
    }));
    
    // 4. Sort by score (highest first)
    jobsWithScores.sort((a, b) => (b.fitScore || 0) - (a.fitScore || 0));
    
    // 5. Return top 5
    return jobsWithScores.slice(0, 5);
}

CACHE INVALIDATION:
-------------------
Scores are recalculated when:
1. User uploads new resume
2. User clicks "Recalculate AI Match Scores" button
3. Score is missing (on-demand calculation)

===================================================================================
                         SECTION 6: API INTEGRATION
===================================================================================

BACKEND â†’ AI SERVICE:
---------------------
ðŸ“ FILE: backend/services/aiService.js

const AI_SERVICE_URL = "http://localhost:8000";

async function calculateFitScore(resumeData, jobData) {
    try {
        const response = await axios.post(
            `${AI_SERVICE_URL}/rag/fit-score`,
            {
                resume_data: resumeData,
                job_data: jobData
            },
            {
                timeout: 30000  // 30 seconds
            }
        );
        
        return response.data.score;
    } catch (error) {
        console.error("Fit score calculation failed:", error);
        return 0;  // Fallback to 0 if AI fails
    }
}

AI SERVICE ENDPOINT:
-------------------
ðŸ“ FILE: AI/rag_service.py

@app.post("/rag/fit-score")
async def calculate_fit_score(request: FitScoreRequest):
    resume_data = request.resume_data
    job_data = request.job_data
    
    # Create prompt
    prompt = f"""
    Resume Skills: {', '.join(resume_data.get('skills', []))}
    Resume Experience: {resume_data.get('experience', '0')} years
    Resume Education: {resume_data.get('education', '')}
    
    Job Required Skills: {', '.join(job_data.get('skills', []))}
    Job Experience Required: {job_data.get('experience', '')}
    Job Education Required: {job_data.get('education', '')}
    
    Calculate fit score (0-100%)...
    """
    
    # Call GPT-4
    response = client.chat.completions.create(
        model="gpt-4o-mini",
        messages=[
            {"role": "system", "content": "You are a job matching expert..."},
            {"role": "user", "content": prompt}
        ]
    )
    
    # Parse score
    score = parse_score(response.choices[0].message.content)
    
    return {"score": score}

===================================================================================
                         SECTION 7: FRONTEND DISPLAY
===================================================================================

ðŸ“ FILE: frontend/src/pages/Dashboard.jsx

DISPLAYING FIT SCORES:
----------------------
1. Fetch recommendations from backend
2. Backend returns jobs with fitScore attached
3. Display score as percentage with progress bar
4. Sort by score (highest first)

CODE:
-----
const [recommendations, setRecommendations] = useState([]);

useEffect(() => {
    const fetchRecommendations = async () => {
        const response = await axios.get("/api/recommendations");
        setRecommendations(response.data);
    };
    fetchRecommendations();
}, []);

return (
    <div>
        {recommendations.map(job => (
            <div key={job._id}>
                <h3>{job.title} at {job.company}</h3>
                <div>
                    <span>Match: {job.fitScore}%</span>
                    <div style={{width: `${job.fitScore}%`, height: "10px", background: "green"}} />
                </div>
            </div>
        ))}
    </div>
);

LOADING STATE:
--------------
While scores are being calculated:
- Show "Calculating match..." spinner
- Disable apply button
- Show progress indicator

===================================================================================
                         SECTION 8: OPTIMIZATION
===================================================================================

PERFORMANCE IMPROVEMENTS:
-------------------------

1. Batch Processing:
   - Calculate all scores at once
   - Reduces API calls
   - Faster overall

2. Caching:
   - Store scores in MongoDB
   - Instant retrieval
   - No recalculation needed

3. On-Demand Calculation:
   - Only calculate for visible jobs (pagination)
   - Lazy loading
   - Faster initial page load

4. Parallel Processing:
   - Process multiple jobs simultaneously
   - Use async/await
   - Faster batch calculation

===================================================================================
                         SECTION 9: ERROR HANDLING
===================================================================================

COMMON ERRORS:
--------------

1. AI Service Timeout:
   - Cause: GPT-4 API slow or unavailable
   - Solution: Retry with exponential backoff
   - Fallback: Return 0 or cached score

2. Resume Data Missing:
   - Cause: Resume not processed yet
   - Solution: Wait for processing to complete
   - Show message to user

3. Job Data Missing:
   - Cause: Job deleted or invalid
   - Solution: Skip that job
   - Continue with others

===================================================================================
                              END OF FIT SCORE NOTES
===================================================================================

Key Takeaways:
- Weighted scoring: 40% skills, 30% experience, 20% education, 10% alignment
- Batch processing for efficiency
- Caching for performance
- On-demand calculation for pagination
- AI-powered for consistency and accuracy

