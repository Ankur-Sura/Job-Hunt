===================================================================================
                    üîê AUTHENTICATION & LOGIN IMPLEMENTATION
===================================================================================

üìñ WHAT IS THIS?
---------------
This document explains how user authentication and login works in the Job Portal.

===================================================================================
                         SECTION 1: OVERVIEW
===================================================================================

Q: How does authentication work?
--------------------------------
A: The project uses JWT (JSON Web Tokens) for stateless authentication.

   Flow:
   1. User enters email + password
   2. Backend verifies credentials against MongoDB
   3. If valid ‚Üí Generate JWT token
   4. Token sent to frontend
   5. Frontend stores token in localStorage
   6. Every API request includes token in Authorization header
   7. Backend middleware verifies token before processing request

===================================================================================
                         SECTION 2: BACKEND IMPLEMENTATION
===================================================================================

üìÅ FILE: backend/routes/auth.js
--------------------------------

REGISTER ENDPOINT:
------------------
POST /api/auth/register

1. Receives: { email, password, name }
2. Checks if user already exists (MongoDB query)
3. Hashes password using bcrypt (10 salt rounds)
4. Creates new User document in MongoDB
5. Generates JWT token (expires in 7 days)
6. Returns: { token, user: { id, email, name } }

CODE FLOW:
----------
router.post("/register", async (req, res) => {
    // 1. Extract email, password, name from request body
    const { email, password, name } = req.body;
    
    // 2. Check if user exists
    const existingUser = await User.findOne({ email });
    if (existingUser) {
        return res.status(400).json({ error: "User already exists" });
    }
    
    // 3. Hash password (bcrypt)
    const hashedPassword = await bcrypt.hash(password, 10);
    
    // 4. Create user in MongoDB
    const user = new User({
        email,
        password: hashedPassword,
        name
    });
    await user.save();
    
    // 5. Generate JWT token
    const token = jwt.sign(
        { userId: user._id, email: user.email },
        process.env.JWT_SECRET,
        { expiresIn: "7d" }
    );
    
    // 6. Return token and user info
    res.json({ token, user: { id: user._id, email: user.email, name: user.name } });
});

LOGIN ENDPOINT:
---------------
POST /api/auth/login

1. Receives: { email, password }
2. Finds user by email in MongoDB
3. Compares password using bcrypt.compare()
4. If match ‚Üí Generate JWT token
5. Returns: { token, user: { id, email, name } }

CODE FLOW:
----------
router.post("/login", async (req, res) => {
    // 1. Extract email and password
    const { email, password } = req.body;
    
    // 2. Find user in database
    const user = await User.findOne({ email });
    if (!user) {
        return res.status(401).json({ error: "Invalid credentials" });
    }
    
    // 3. Compare password
    const isMatch = await bcrypt.compare(password, user.password);
    if (!isMatch) {
        return res.status(401).json({ error: "Invalid credentials" });
    }
    
    // 4. Generate JWT token
    const token = jwt.sign(
        { userId: user._id, email: user.email },
        process.env.JWT_SECRET,
        { expiresIn: "7d" }
    );
    
    // 5. Return token and user info
    res.json({ token, user: { id: user._id, email: user.email, name: user.name } });
});

AUTHENTICATION MIDDLEWARE:
--------------------------
üìÅ FILE: backend/middleware/auth.js

This middleware protects routes that require authentication.

HOW IT WORKS:
-------------
1. Extracts token from Authorization header
2. Verifies token using JWT_SECRET
3. Extracts userId from token
4. Finds user in MongoDB
5. Attaches user to req.user
6. Calls next() to continue to route handler

CODE:
-----
const jwt = require("jsonwebtoken");
const User = require("../models/User");

module.exports = async (req, res, next) => {
    try {
        // 1. Get token from header
        const authHeader = req.headers.authorization;
        if (!authHeader || !authHeader.startsWith("Bearer ")) {
            return res.status(401).json({ error: "No token provided" });
        }
        
        const token = authHeader.split(" ")[1];  // Remove "Bearer " prefix
        
        // 2. Verify token
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        
        // 3. Find user
        const user = await User.findById(decoded.userId);
        if (!user) {
            return res.status(401).json({ error: "User not found" });
        }
        
        // 4. Attach user to request
        req.user = user;
        next();  // Continue to route handler
    } catch (error) {
        res.status(401).json({ error: "Invalid token" });
    }
};

USAGE IN ROUTES:
----------------
// Protect a route
router.get("/dashboard", authMiddleware, async (req, res) => {
    // req.user is available here (set by middleware)
    const userId = req.user._id;
    // ... rest of code
});

===================================================================================
                         SECTION 3: FRONTEND IMPLEMENTATION
===================================================================================

üìÅ FILE: frontend/src/context/AuthContext.jsx
---------------------------------------------

AUTH CONTEXT:
-------------
Provides authentication state and functions to all components.

STATE:
------
- user: Current user object (null if not logged in)
- token: JWT token (stored in localStorage)
- loading: Loading state

FUNCTIONS:
----------
- login(email, password): Calls API, stores token, updates state
- register(email, password, name): Calls API, stores token, updates state
- logout(): Removes token, clears state
- checkAuth(): Checks if token exists, validates it

CODE FLOW (LOGIN):
------------------
const login = async (email, password) => {
    try {
        // 1. Call backend API
        const response = await axios.post("http://localhost:8080/api/auth/login", {
            email,
            password
        });
        
        // 2. Extract token and user from response
        const { token, user } = response.data;
        
        // 3. Store token in localStorage
        localStorage.setItem("token", token);
        
        // 4. Update state
        setUser(user);
        setToken(token);
        
        // 5. Set default Authorization header for future requests
        axios.defaults.headers.common["Authorization"] = `Bearer ${token}`;
        
        return { success: true };
    } catch (error) {
        return { success: false, error: error.response?.data?.error };
    }
};

üìÅ FILE: frontend/src/pages/Login.jsx
-------------------------------------

LOGIN COMPONENT:
----------------
1. Form with email and password inputs
2. onSubmit handler calls AuthContext.login()
3. On success ‚Üí Navigate to /dashboard
4. On error ‚Üí Show error message

CODE:
-----
const Login = () => {
    const { login } = useAuth();
    const navigate = useNavigate();
    const [email, setEmail] = useState("");
    const [password, setPassword] = useState("");
    const [error, setError] = useState("");
    
    const handleSubmit = async (e) => {
        e.preventDefault();
        const result = await login(email, password);
        if (result.success) {
            navigate("/dashboard");
        } else {
            setError(result.error);
        }
    };
    
    return (
        <form onSubmit={handleSubmit}>
            <input value={email} onChange={(e) => setEmail(e.target.value)} />
            <input type="password" value={password} onChange={(e) => setPassword(e.target.value)} />
            <button type="submit">Login</button>
            {error && <p>{error}</p>}
        </form>
    );
};

PROTECTED ROUTES:
-----------------
üìÅ FILE: frontend/src/components/ProtectedRoute.jsx

Wraps routes that require authentication.

CODE:
-----
const ProtectedRoute = ({ children }) => {
    const { user, loading } = useAuth();
    const navigate = useNavigate();
    
    useEffect(() => {
        if (!loading && !user) {
            navigate("/login");
        }
    }, [user, loading, navigate]);
    
    if (loading) return <div>Loading...</div>;
    if (!user) return null;
    
    return children;
};

USAGE:
------
<Route path="/dashboard" element={
    <ProtectedRoute>
        <Dashboard />
    </ProtectedRoute>
} />

===================================================================================
                         SECTION 4: API INTEGRATION
===================================================================================

AXIOS CONFIGURATION:
--------------------
üìÅ FILE: frontend/src/utils/axios.js (or similar)

Sets up axios to include token in all requests.

CODE:
-----
import axios from "axios";

// Get token from localStorage
const token = localStorage.getItem("token");

// Set default Authorization header
if (token) {
    axios.defaults.headers.common["Authorization"] = `Bearer ${token}`;
}

// Interceptor to add token to every request
axios.interceptors.request.use((config) => {
    const token = localStorage.getItem("token");
    if (token) {
        config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
});

// Interceptor to handle 401 errors (unauthorized)
axios.interceptors.response.use(
    (response) => response,
    (error) => {
        if (error.response?.status === 401) {
            // Token expired or invalid
            localStorage.removeItem("token");
            window.location.href = "/login";
        }
        return Promise.reject(error);
    }
);

===================================================================================
                         SECTION 5: SECURITY CONSIDERATIONS
===================================================================================

PASSWORD HASHING:
-----------------
- Uses bcrypt with 10 salt rounds
- Passwords NEVER stored in plain text
- Even if database is compromised, passwords are safe

JWT TOKEN:
----------
- Contains: userId, email
- Signed with JWT_SECRET (stored in .env)
- Expires in 7 days
- Token is stateless (no database lookup needed for verification)

SECURITY BEST PRACTICES:
-----------------------
1. ‚úÖ Passwords hashed with bcrypt
2. ‚úÖ JWT_SECRET stored in environment variables
3. ‚úÖ Token expiration (7 days)
4. ‚úÖ HTTPS in production (not implemented in dev)
5. ‚úÖ CORS configured
6. ‚úÖ Input validation on backend

===================================================================================
                         SECTION 6: DATABASE SCHEMA
===================================================================================

üìÅ FILE: backend/models/User.js
--------------------------------

USER SCHEMA:
------------
{
    _id: ObjectId,
    email: String (unique, required),
    password: String (hashed, required),
    name: String (required),
    createdAt: Date,
    updatedAt: Date
}

INDEXES:
--------
- email: Unique index for fast lookups

===================================================================================
                         SECTION 7: ERROR HANDLING
===================================================================================

COMMON ERRORS:
--------------

1. "User already exists"
   - Cause: Email already registered
   - Solution: Use different email or login

2. "Invalid credentials"
   - Cause: Wrong email or password
   - Solution: Check email/password

3. "No token provided"
   - Cause: Request missing Authorization header
   - Solution: Login first

4. "Invalid token"
   - Cause: Token expired or tampered
   - Solution: Login again

5. "User not found"
   - Cause: User deleted but token still valid
   - Solution: Login again

===================================================================================
                         SECTION 8: TESTING
===================================================================================

MANUAL TESTING:
---------------

1. Register:
   curl -X POST http://localhost:8080/api/auth/register \
     -H "Content-Type: application/json" \
     -d '{"email":"test@example.com","password":"test123","name":"Test User"}'

2. Login:
   curl -X POST http://localhost:8080/api/auth/login \
     -H "Content-Type: application/json" \
     -d '{"email":"test@example.com","password":"test123"}'

3. Protected Route:
   curl -X GET http://localhost:8080/api/jobs \
     -H "Authorization: Bearer YOUR_TOKEN_HERE"

===================================================================================
                              END OF AUTHENTICATION NOTES
===================================================================================

Key Takeaways:
- JWT tokens for stateless authentication
- bcrypt for password hashing
- Middleware protects routes
- Frontend stores token in localStorage
- Axios interceptors handle token automatically

